<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #8b7355 0%, #6b5344 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        .monitor {
            background: linear-gradient(180deg, #e8dcc8 0%, #d4c4a8 50%, #c4b498 100%);
            border-radius: 3px;
            padding: 50px 40px 80px 40px;
            box-shadow: 
                0 25px 70px rgba(0, 0, 0, 0.6),
                inset 0 2px 0 rgba(255, 255, 255, 0.3),
                inset 0 -3px 8px rgba(0, 0, 0, 0.2),
                inset 3px 0 8px rgba(0, 0, 0, 0.15),
                inset -3px 0 8px rgba(0, 0, 0, 0.15);
            position: relative;
            max-width: 900px;
            width: 100%;
        }

        .monitor::before {
            content: 'VT-220';
            position: absolute;
            bottom: 35px;
            left: 40px;
            font-family: Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            color: #6b5344;
            letter-spacing: 2px;
        }

        .monitor::after {
            content: '';
            position: absolute;
            top: 20px;
            right: 40px;
            width: 8px;
            height: 8px;
            background: #ff3300;
            border-radius: 50%;
            box-shadow: 
                0 0 8px #ff3300,
                inset 0 -1px 2px rgba(0, 0, 0, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            animation: powerLight 2s ease-in-out infinite;
        }

        @keyframes powerLight {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .screen-bezel {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border-radius: 2px;
            padding: 25px;
            box-shadow: 
                inset 0 4px 12px rgba(0, 0, 0, 0.9),
                inset 0 0 0 2px #3a3a3a,
                inset 4px 4px 8px rgba(0, 0, 0, 0.8),
                inset -2px -2px 6px rgba(80, 80, 80, 0.3);
            border: 3px solid #4a4a4a;
        }

        .screen {
            background: #000a00;
            border-radius: 0;
            padding: 20px;
            min-height: 400px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 0 80px rgba(0, 255, 0, 0.08),
                0 0 30px rgba(0, 255, 0, 0.15);
            border: 1px solid #001a00;
        }

        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 3px;
            pointer-events: none;
            animation: scanlines 10s linear infinite;
            z-index: 2;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(3px); }
        }

        .screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.4) 100%);
            pointer-events: none;
            z-index: 2;
        }

        #terminal {
            position: relative;
            z-index: 1;
        }

        /* Override xterm.js styles for 1980s look */
        .xterm {
            font-family: 'Courier New', monospace !important;
            font-size: 15px !important;
            line-height: 1.4 !important;
            letter-spacing: 0.5px !important;
        }

        .xterm .xterm-viewport {
            background-color: transparent !important;
            overflow-y: auto !important;
        }

        .xterm .xterm-screen {
            background-color: transparent !important;
        }

        .xterm .xterm-cursor-layer .xterm-cursor {
            background-color: #33ff33 !important;
        }

        .xterm .xterm-rows {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
        }

        .xterm .xterm-row {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
        }
    </style>
</head>
<body>
    <div class="monitor">
        <div class="screen-bezel">
            <div class="screen">
                <div id="terminal"></div>
            </div>
        </div>
    </div>

    <script>
        // Initialize xterm.js
        const term = new Terminal({
            cursorBlink: true,
            cursorStyle: 'block',
            theme: {
                background: 'transparent',
                foreground: '#33ff33',
                cursor: '#33ff33',
                cursorAccent: '#000a00',
                selectionBackground: 'rgba(51, 255, 51, 0.3)'
            },
            fontFamily: '"Courier New", monospace',
            fontSize: 15,
            lineHeight: 1.4,
            letterSpacing: 0.5,
            cols: 80,
            rows: 24,
            convertEol: true,
            scrollback: 1000
        });

        term.open(document.getElementById('terminal'));

        // Display boot sequence
        term.writeln('DEC VT-220 Compatible Terminal');
        term.writeln('ROM Version 2.3');
        term.writeln('Copyright (c) Digital Equipment Corp. 1988');
        term.writeln('');
        term.writeln('Performing self-test................ OK');
        term.writeln('Keyboard initialized................ OK');
        term.writeln('');

        // Command buffer
        let currentLine = '';
        let commandHistory = [];
        let historyIndex = -1;

        // Show prompt
        function prompt() {
            term.write('$ ');
        }

        prompt();

        // Utility function to wrap text to specified width
        function wrapText(text, maxWidth) {
            if (!text) return [''];
            
            const lines = [];
            const paragraphs = text.split('\n');
            
            paragraphs.forEach(paragraph => {
                if (!paragraph.trim()) {
                    lines.push('');
                    return;
                }
                
                const words = paragraph.split(' ');
                let currentLine = '';

                for (const word of words) {
                    if (word.length > maxWidth) {
                        // If a single word is longer than maxWidth, break it
                        if (currentLine.trim()) {
                            lines.push(currentLine.trim());
                            currentLine = '';
                        }
                        for (let i = 0; i < word.length; i += maxWidth) {
                            lines.push(word.slice(i, i + maxWidth));
                        }
                    } else if ((currentLine + word).length > maxWidth) {
                        lines.push(currentLine.trim());
                        currentLine = word + ' ';
                    } else {
                        currentLine += word + ' ';
                    }
                }

                if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                }
            });

            return lines.length > 0 ? lines : [''];
        }

        // This is the function you can customize to handle commands
        function handleCommand(command) {
            command = command.trim();
            
            if (!command) {
                return '';
            }

            // Add to history
            commandHistory.push(command);
            historyIndex = commandHistory.length;

            // Simple command responses
            const commands = {
                help: 'Available commands: help, clear, date, echo [text], hello, about',
                date: new Date().toString(),
                hello: 'Hello, user! Welcome to the retro terminal.',
                about: 'Skeuomorphic Terminal - A nostalgic throwback to the computing of yesteryear. This terminal emulator recreates the look and feel of 1980s computer terminals with authentic green phosphor display, scanlines, and period-appropriate beige monitor casing.',
            };

            // Handle clear command
            if (command.toLowerCase() === 'clear') {
                term.clear();
                return '';
            }

            // Handle echo command
            if (command.toLowerCase().startsWith('echo ')) {
                return command.substring(5);
            }

            // Check built-in commands
            const cmd = command.toLowerCase();
            if (commands[cmd]) {
                return commands[cmd];
            }

            // Default response for unknown commands
            return `Command not found: ${command}. Type 'help' for available commands.`;
        }

        // Handle keyboard input
        term.onData(data => {
            const code = data.charCodeAt(0);

            // Handle Enter key
            if (code === 13) {
                term.write('\r\n');
                const output = handleCommand(currentLine);
                if (output) {
                    // Wrap long output text
                    const lines = wrapText(output, 80);
                    lines.forEach(line => term.writeln(line));
                }
                currentLine = '';
                prompt();
            }
            // Handle Backspace
            else if (code === 127) {
                if (currentLine.length > 0) {
                    currentLine = currentLine.slice(0, -1);
                    term.write('\b \b');
                }
            }
            // Handle Ctrl+C
            else if (code === 3) {
                term.write('^C\r\n');
                currentLine = '';
                prompt();
            }
            // Handle Up Arrow (previous command in history)
            else if (data === '\x1b[A') {
                if (historyIndex > 0) {
                    // Clear current line
                    term.write('\r\x1b[K');
                    prompt();
                    
                    historyIndex--;
                    currentLine = commandHistory[historyIndex];
                    term.write(currentLine);
                }
            }
            // Handle Down Arrow (next command in history)
            else if (data === '\x1b[B') {
                // Clear current line
                term.write('\r\x1b[K');
                prompt();
                
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    currentLine = commandHistory[historyIndex];
                    term.write(currentLine);
                } else {
                    historyIndex = commandHistory.length;
                    currentLine = '';
                }
            }
            // Handle regular characters
            else if (code >= 32 && code < 127) {
                currentLine += data;
                term.write(data);
            }
        });

        // Focus terminal on click
        document.getElementById('terminal').addEventListener('click', () => {
            term.focus();
        });

        // Auto-focus on load
        term.focus();
    </script>
</body>
</html>
